(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{433:function(_,v,t){"use strict";t.r(v);var a=t(4),p=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"五大内存区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五大内存区"}},[_._v("#")]),_._v(" 五大内存区")]),_._v(" "),v("p",[_._v("在iOS中，内存主要分为栈区、堆区、全局区、常量区、代码区五大区域\n"),v("img",{attrs:{src:_.$withBase("/system/2.png")}})]),_._v(" "),v("h3",{attrs:{id:"栈区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈区"}},[_._v("#")]),_._v(" 栈区")]),_._v(" "),v("p",[_._v("定义")]),_._v(" "),v("p",[_._v("栈是系统数据结构，其 对应的进程或者线程是唯一 的")]),_._v(" "),v("p",[_._v("栈是 向低地址扩展 的数据结构")]),_._v(" "),v("p",[_._v("栈是一块连续的内存区域，遵循 先进后出(FILO) 原则")]),_._v(" "),v("p",[_._v("栈的地址空间在iOS中是以 0X7或者0X16开头")]),_._v(" "),v("p",[_._v("栈区一般在 运行时分配")]),_._v(" "),v("p",[_._v("存储")]),_._v(" "),v("p",[_._v("栈区是由编译器 自动分配并释放 的，主要用来存储")]),_._v(" "),v("p",[_._v("局部变量")]),_._v(" "),v("p",[_._v("函数的参数，例如函数的隐藏参数（id self，SEL _cmd")]),_._v(" "),v("p",[_._v("优缺")]),_._v(" "),v("p",[_._v("优点：因为栈是由编译器自动分配并释放的，不会产生内存碎片，所以快速高效")]),_._v(" "),v("p",[_._v("缺点：栈的内存大小有限制，数据不灵活")]),_._v(" "),v("p",[_._v("OS X(MAC上)主线程栈大小是8MB")]),_._v(" "),v("p",[_._v("iOS主线程栈大小是1MB")]),_._v(" "),v("p",[_._v("其他线程是512KB")]),_._v(" "),v("h3",{attrs:{id:"堆区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆区"}},[_._v("#")]),_._v(" 堆区")]),_._v(" "),v("p",[_._v("堆是 向高地址扩展 的数据结构")]),_._v(" "),v("p",[_._v("堆是 不连续 的内存区域，类似于链表结构（便于增删，不便于查询），遵循先进先出 （FIFO） 原则")]),_._v(" "),v("p",[_._v("堆的地址空间在iOS中是以 0x6 开头，其空间的分配总是动态的")]),_._v(" "),v("p",[_._v("堆区的分配一般是在 运行时分配")]),_._v(" "),v("p",[_._v("储存")]),_._v(" "),v("p",[_._v("堆区是由程序员动态分配和释放的，如果程序员不释放，程序结束后，可能由操作系统回收，主要用于存放")]),_._v(" "),v("p",[_._v("OC中使用alloc或者 使用new开辟空间创建对象\nC语言中使用malloc、calloc、realloc分配的空间，需要free释放")]),_._v(" "),v("p",[_._v("优缺")]),_._v(" "),v("p",[_._v("优点：灵活方便，数据适应面广泛")]),_._v(" "),v("p",[_._v("缺点：需手动管理，速度慢、容易产生内存碎片\n当需要访问堆中内存时，一般需要先 通过对象读取到栈区的指针地址 ，然后通过 指针地址 访问堆区")]),_._v(" "),v("h2",{attrs:{id:"全局区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全局区"}},[_._v("#")]),_._v(" 全局区")]),_._v(" "),v("p",[_._v("全局区是编译时分配的内存空间")]),_._v(" "),v("p",[_._v("在iOS中一般以 0x1 开头")]),_._v(" "),v("p",[_._v("在程序运行过程中，此内存中的数据一直存在，程序结束后由系统释放，主要存放")]),_._v(" "),v("ul",[v("li",[_._v("未初始化的全局变量和静态变量，即BSS区（.bss）")]),_._v(" "),v("li",[_._v("已初始化的全局变量和静态变量，即数据区（.data）\nBBS:Block Started by Symbol")])]),_._v(" "),v("p",[_._v("其中，全局变量是指变量值可以在运行时被动态修改，而静态变量是static修饰的变量，包含静态局部变量和静态全局变量")]),_._v(" "),v("p",[_._v("常量区\n常量区(.rodata)是 编译时分配 的内存空间，在程序结束后由系统释放，主要存放")]),_._v(" "),v("p",[_._v("已经使用了的，且没有指向的字符串常量\n字符串常量因为可能在程序中被多次使用，所以在程序运行之前就会提前分配内存")]),_._v(" "),v("p",[_._v("代码区")]),_._v(" "),v("p",[_._v("代码区是 编译时分配 主要用于存放程序运行时的代码,代码会被编译成 二进制 存进内存的")]),_._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),v("p",[_._v("一个程序在内存上由BSS段、data段、text段三个组成的。在没有调入内存前，可执行程序分为代码段、数据区和未初始化数据区三部分")]),_._v(" "),v("p",[_._v("BSS段：（Block Started by Symbol）\n通常是指用来存放程序中未初始化的全局变量的一块内存区域，属于静态内存分配。BSS段的内容并不存放在磁盘上的程序文件中。原因是内核在程序开始运行前将它们设置为0，需要存放在程序文件中的只有正文段和初始化数据段。text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。")]),_._v(" "),v("p",[_._v("数据段：（data segment）")]),_._v(" "),v("p",[_._v("通常是指用来存放程序中已初始化的全局变量的一块内存区域，属于静态内存分配。总结为：初始化的全局变量和静态变量在已初始化区域，未初始化的全局变量和静态变量在BSS区。")]),_._v(" "),v("p",[_._v("代码段：（code segment/text segment）")]),_._v(" "),v("p",[_._v("通常是指用来存放程序执行代码的一块内存区域。该区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。")]),_._v(" "),v("p",[_._v("堆（heap）：")]),_._v(" "),v("p",[_._v("用于动态分配内存，位于BSS和栈中间的地址区域，由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，会产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间，因此堆的效率比栈要低的多。注：与数据结构中的堆不是一个概念，但堆的分配方式类似于链表。")]),_._v(" "),v("p",[_._v("栈(stack)：")]),_._v(" "),v("p",[_._v("由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中，这个被调用的函数再为它的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出。")]),_._v(" "),v("p",[_._v("堆和栈的区别在于")]),_._v(" "),v("p",[_._v("1）管理方式：栈由编译器自动管理，无需人为控制。而堆释放工作由程序员控制，容易产生内存泄漏（memory leak）。")]),_._v(" "),v("p",[_._v("2）空间大小：在32位系统下，堆内存可以达到4G的空间（虚拟内存的大小，有面试官问过），从这个角度来看堆内存大小可以很大。但对于栈来说，一般都是有一定的空间大小的")]),_._v(" "),v("p",[_._v("3）碎片问题：堆频繁new/delete会造成内存空间的不连续，造成大量的碎片，使程序效率降低（重点是如何解决？如内存池、伙伴系统等）。对栈来说不会存在这个问题，因为栈是先进后出，不可能有一个内存块从栈中间弹出。在该块弹出之前，在它上面的（后进的栈内容）已经被弹出。")]),_._v(" "),v("p",[_._v("4）生长方向：堆生长（扩展）方向是向上的，也就是向着内存地址增加的方向；栈生长（扩展）方向是向下的，是向着内存地址减小的方向增长， 可以看第一张图。")]),_._v(" "),v("p",[_._v("5）分配方式：堆都是动态分配的，没有静态分配的堆。而栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，如局部变量分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。")]),_._v(" "),v("p",[_._v("6）效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持（有专门的寄存器存放栈的地址，压栈出栈都有专门的机器指令执行），这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的（可以了解侯捷老师的内存管理的视频，关于malloc/realloc/free函数等）。例如分配一块内存，堆会按照一定的算法，在堆内存中搜索可用的足够大小的空间，如果没有（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。总之，堆的效率比栈要低得多。")]),_._v(" "),v("p",[_._v("参考文档：https://blog.csdn.net/m0_74703932/article/details/139127718")])])}),[],!1,null,null,null);v.default=p.exports}}]);