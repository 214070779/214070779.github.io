(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{418:function(a,n,s){"use strict";s.r(n);var t=s(4),e=Object(t.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"一、概述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、概述"}},[a._v("#")]),a._v(" 一、概述")]),a._v(" "),n("p",[a._v("运行时架构(runtime architecture)是针对软件运行环境定义的一系列规则，包括但不限于：")]),a._v(" "),n("p",[a._v("如何为代码和数据(code and data)排位；\n在内存中怎样去加载或者追踪程序的部分代码；\n告诉编译器应该如何组装代码；\n如何调用系统服务，如加载插件；\nMac 系统支持多种运行时架构，但是内核可以直接读取的可执行文件只有一种：Mach-O。因此，mac 的运行时架构也被命名为：Mach-O Runtime Architecture；因此，Mach-O 是一种存储标准，用于 Mach-O runtime architecture 架构中对程序的磁盘存储；")]),a._v(" "),n("p",[a._v("Mach-O 是 mach object 的缩写，在 -objc解决分类不加载的问题的官方文档中，明确指出所有的源文件都会被转化成一个 objcet，只不过最后经过链接操作，工程或被转化成静态库、动态库或者是可执行文件(类型不同的 mach-O)；")]),a._v(" "),n("p",[a._v("Mach-O 文件分为三大部分：")]),a._v(" "),n("p",[n("strong",[a._v("文件头：")])]),a._v(" "),n("p",[a._v("Header（头部），指明了 cpu 架构、大小端序、文件类型、Load Commands 个数等一些基本信息")]),a._v(" "),n("p",[n("strong",[a._v("命令区域：")])]),a._v(" "),n("p",[a._v("Load Commands（加载命令)，正如官方的图所示，描述了怎样加载每个 Segment 的信息。在 Mach-O 文件中可以有多个 Segment，每个 Segment 可能包含一个或多个 Section,segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。")]),a._v(" "),n("p",[n("strong",[a._v("数据区域（包括数据， 代码等等）：")])]),a._v(" "),n("p",[a._v("Data（数据区），Segment 的具体数据，包含了代码和数据等。")]),a._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdn.net/20141114102704167",alt:""}})]),a._v(" "),n("h2",{attrs:{id:"二、mach-header"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、mach-header"}},[a._v("#")]),a._v(" 二、mach_header")]),a._v(" "),n("p",[a._v("header 位于 Mach-O 文件的头部，其作用是：")]),a._v(" "),n("p",[a._v("识别 Mach-O 的格式； 文件类型； CPU 架构信息； 64 位 header 结构体如下：")]),a._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[a._v("struct mach_header_64 "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    uint32_t    magic"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("      "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 主要用来区分当前Mach-O所支持的CPU架构(当前只有32bit和64bit)。*/")]),a._v("\n    cpu_type_t  cputype"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 主要的CPU类型(32/64bit), 以及其他的属性*/")]),a._v("\n    cpu_subtype_t   cpusubtype"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* arm 架构下有 arm_v7、arm_all 之类的区别，而 subtype 就是表示这个，部分定义如下： */")]),a._v("\n    uint32_t    filetype"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* filetype 就是我们熟知的 Mach-O 文件的类型，比如动态库、主工程生成可执行文件、bundle 等等 */")]),a._v("\n    uint32_t    ncmds"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("      "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 也就是下一个segment中得segment的数量。number of load commands */")]),a._v("\n    uint32_t    sizeofcmds"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* 表示 header 之后的 Load Command 的段数和大小 */")]),a._v("\n    uint32_t    flags"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("      "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* flags */")]),a._v("\n    uint32_t    reserved"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/* reserved */")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br")])]),n("h2",{attrs:{id:"load-command-源码解读"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#load-command-源码解读"}},[a._v("#")]),a._v(" Load Command 源码解读")]),a._v(" "),n("p",[a._v("Load Command 由多个 command 组成；\ncommand 主要有两种类型：指向具体数据、不指向具体数据；\n代码层面上 load_command 结构体相当于基类，很少被使用；")]),a._v(" "),n("h2",{attrs:{id:"load-command-和-segment-section-的关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#load-command-和-segment-section-的关系"}},[a._v("#")]),a._v(" Load Command 和 segment/section 的关系")]),a._v(" "),n("p",[a._v("上文中讲到 Load Command 主要分为指向数据实体和不指向数据实体两种类型。")]),a._v(" "),n("p",[a._v("不指向数据实体的 command 主要作用是为 dyld 提供信息，而指向数据实体的 command 才是 command 和 segment/section 关系的体现；")]),a._v(" "),n("p",[a._v("如 LC_SEGMENT 指向具体的 segment，这个 segment 的实体部分就是 Mach-O 文件的第三部分，主要内容是代码和数据；")]),a._v(" "),n("p",[a._v("Mac-O加载流程")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("execve       // 用户点击了app，用户态会发送一个系统调用 execve 到内核\n  ▼ __mac_execve  // 主要是为加载镜像进行数据的初始化，以及资源相关的操作，以及创建线程\n    ▼ exec_activate_image // 拷贝可执行文件到内存中，并根据不同的可执行文件类型选择不同的加载函数，所有的镜像的加载要么终止在一个错误上，要么最终完成加载镜像。\n      // 在 encapsulated_binary 这一步会根据image的类型选择imgact的方法\n      /*\n       * 该方法为Mach-o Binary对应的执行方法；\n       * 如果image类型为Fat Binary，对应方法为exec_fat_imgact；\n       * 如果image类型为Interpreter Script，对应方法为exec_shell_imgact\n       */\n      ▼ exec_mach_imgact   \n        ▶︎ // 首先对Mach-O做检测，会检测Mach-O头部，解析其架构、检查imgp等内容，判断魔数、cputype、cpusubtype等信息。如果image无效，会直接触发assert(exec_failure_reason == OS_REASON_NULL); 退出。\n          // 拒绝接受Dylib和Bundle这样的文件，这些文件会由dyld负责加载。然后把Mach-O映射到内存中去，调用load_machfile()\n        ▼ load_machfile\n          ▶︎ // load_machfile会加载Mach-O中的各种load command命令。在其内部会禁止数据段执行，防止溢出漏洞攻击，还会设置地址空间布局随机化（ASLR），还有一些映射的调整。\n            // 真正负责对加载命令解析的是parse_machfile()\n          ▼ parse_machfile  //解析主二进制macho\n            ▶︎ /* \n               * 首先，对image头中的filetype进行分析，可执行文件MH_EXECUTE不允许被二次加载(depth = 1)；动态链接编辑器MH_DYLINKER必须是被可执行文件加载的(depth = 2)\n               * 然后，循环遍历所有的load command，分别调用对应的内核函数进行处理\n               *   LC_SEGMET：load_segment函数：对于每一个段，将文件中相应的内容加载到内存中：从偏移量为 fileoff 处加载 filesize 字节到虚拟内存地址 vmaddr 处的 vmsize 字节。每一个段的页面都根据 initprot 进行初始化，initprot 指定了如何通过读/写/执行位初始化页面的保护级别。\n               *   LC_UNIXTHREAD：load_unixthread函数，见下文\n               *   LC_MAIN：load_main函数\n               *   LC_LOAD_DYLINKER：获取动态链接器相关的信息，下面load_dylinker会根据信息，启动动态链接器\n               *   LC_CODE_SIGNATURE：load_code_signature函数，进行验证，如果无效会退出。理论部分，回见第二节load_command `LC_CODE_SIGNATURE `部分。\n               *   其他的不再多说，有兴趣可以自己看源码\n               */\n            ▼ load_dylinker // 解析完 macho后，根据macho中的 LC_LOAD_DYLINKER 这个LoadCommand来启动这个二进制的加载器，即 /usr/bin/dyld\n              ▼ parse_machfile // 开始解析 dyld 这个mach-o文件\n                ▼ load_unixthread // 解析 dyld 的 LC_UNIXTHREAD 命令，这个过程中会解析出entry_point\n                  ▼ load_threadentry  // 获取入口地址\n                    ▶︎ thread_entrypoint  // 里面只有i386和x86架构的，没有arm的，但是原理是一样的\n                  ▶︎ //上一步获取到地址后，会再加上slide，ASLR偏移，到此，就获取到了dyld的入口地址，也就是 _dyld_start 函数的地址\n        ▼ activate_exec_state\n          ▶︎ thread_setentrypoint // 设置entry_point。直接把entry_point地址写入到用户态的寄存器里面了。\n          //这一步开始，_dyld_start就真正开始执行了。\n\n▼ dyld\n  ▼ __dyld_start  // 源码在dyldStartup.s这个文件，用汇编实现\n    ▼ dyldbootstrap::start() \n      ▼ dyld::_main()\n        ▼ //函数的最后，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行\n        ▼ 这是下篇内容\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br"),n("span",{staticClass:"line-number"},[a._v("13")]),n("br"),n("span",{staticClass:"line-number"},[a._v("14")]),n("br"),n("span",{staticClass:"line-number"},[a._v("15")]),n("br"),n("span",{staticClass:"line-number"},[a._v("16")]),n("br"),n("span",{staticClass:"line-number"},[a._v("17")]),n("br"),n("span",{staticClass:"line-number"},[a._v("18")]),n("br"),n("span",{staticClass:"line-number"},[a._v("19")]),n("br"),n("span",{staticClass:"line-number"},[a._v("20")]),n("br"),n("span",{staticClass:"line-number"},[a._v("21")]),n("br"),n("span",{staticClass:"line-number"},[a._v("22")]),n("br"),n("span",{staticClass:"line-number"},[a._v("23")]),n("br"),n("span",{staticClass:"line-number"},[a._v("24")]),n("br"),n("span",{staticClass:"line-number"},[a._v("25")]),n("br"),n("span",{staticClass:"line-number"},[a._v("26")]),n("br"),n("span",{staticClass:"line-number"},[a._v("27")]),n("br"),n("span",{staticClass:"line-number"},[a._v("28")]),n("br"),n("span",{staticClass:"line-number"},[a._v("29")]),n("br"),n("span",{staticClass:"line-number"},[a._v("30")]),n("br"),n("span",{staticClass:"line-number"},[a._v("31")]),n("br"),n("span",{staticClass:"line-number"},[a._v("32")]),n("br"),n("span",{staticClass:"line-number"},[a._v("33")]),n("br"),n("span",{staticClass:"line-number"},[a._v("34")]),n("br"),n("span",{staticClass:"line-number"},[a._v("35")]),n("br"),n("span",{staticClass:"line-number"},[a._v("36")]),n("br"),n("span",{staticClass:"line-number"},[a._v("37")]),n("br"),n("span",{staticClass:"line-number"},[a._v("38")]),n("br"),n("span",{staticClass:"line-number"},[a._v("39")]),n("br"),n("span",{staticClass:"line-number"},[a._v("40")]),n("br"),n("span",{staticClass:"line-number"},[a._v("41")]),n("br"),n("span",{staticClass:"line-number"},[a._v("42")]),n("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);