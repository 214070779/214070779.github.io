(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{440:function(n,s,a){"use strict";a.r(s);var t=a(4),e=Object(t.a)({},(function(){var n=this,s=n._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h3",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[n._v("#")])]),n._v(" "),s("h1",{attrs:{id:"时间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[n._v("#")]),n._v(" 时间复杂度")]),n._v(" "),s("ol",[s("li",[n._v("事前分析估算法。在计算机程序编制前，依据统计方法对算法进行估算，如根据时间复杂度来估算算法时间效率。")])]),n._v(" "),s("blockquote",[s("p",[n._v("一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示。若有某个辅助函数 f(n)，使得当 n 接近于无穷大时，T(n) / f(n)的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 T(n) = O(f(n))。它表示岁问题规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。这样用大 O()来体现算法时间复杂度的方法，我们称之为大 O 记法。")])]),n._v(" "),s("p",[n._v("常见的时间复杂度：")]),n._v(" "),s("ul",[s("li",[n._v("常数阶 O(1)")]),n._v(" "),s("li",[n._v("对数阶 O(log2n)")]),n._v(" "),s("li",[n._v("线性阶 O(n)")]),n._v(" "),s("li",[n._v("线性对数阶 O(nlog2n)")]),n._v(" "),s("li",[n._v("平方阶 O(n^2)")]),n._v(" "),s("li",[n._v("立方阶 O(n^3)")]),n._v(" "),s("li",[n._v("K 次方阶 O(n^k)")]),n._v(" "),s("li",[n._v("指数阶 O(2^n)")])]),n._v(" "),s("p",[s("img",{attrs:{src:"https://www.sqlboy.tech/img/data_structure/bigo.png",alt:""}})]),n._v(" "),s("p",[n._v("从上往下，时间复杂度依次增大，且随着问题规模 n 的增大，差异愈发明显。常见算法时间复杂度代码示例如下：")]),n._v(" "),s("h3",{attrs:{id:"常数阶o-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常数阶o-1"}},[n._v("#")]),n._v(" 常数阶O(1)：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("int a = 0;\nint b = 0;\nint c = a + b;\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("h3",{attrs:{id:"线性阶o-n"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线性阶o-n"}},[n._v("#")]),n._v(" 线性阶O(n)：")]),n._v(" "),s("p",[n._v("线性阶的操作数量相对于输入数据大小n以线性级别增长。线性阶通常出现在单层循环中：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("for (int i = 0; i < n; i++){\n    // 时间复杂度为O(1)的算法\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("h3",{attrs:{id:"平方阶o-n-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#平方阶o-n-2"}},[n._v("#")]),n._v(" 平方阶O(n^2)：")]),n._v(" "),s("p",[n._v("平方阶的操作数量相对于输入数据大小  以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为 O(n)，因此总体的时间复杂度为 O(n^2)：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("for (int i = 0; i < n; i++){\n    for (int j = 0; j < n; j++){\n        // 时间复杂度为O(1)的算法\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_constant_linear_quadratic.png",alt:"常数阶、线性阶和平方阶的时间复杂度"}})]),n._v(" "),s("h3",{attrs:{id:"指数阶o-2-n"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指数阶o-2-n"}},[n._v("#")]),n._v(" 指数阶O(2^n)：")]),n._v(" "),s("p",[n._v("生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 1个细胞，分裂一轮后变为 2个，分裂两轮后变为 4个，以此类推，分裂 n轮后有 2^n个细胞。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("/* 指数阶（循环实现） */\nint exponential(int n) {\n    int count = 0;\n    int bas = 1;\n    // 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < bas; j++) {\n            count++;\n        }\n        bas *= 2;\n    }\n    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1\n    return count;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_exponential.png",alt:"指数阶的时间复杂度"}})]),n._v(" "),s("h3",{attrs:{id:"对数阶o-logn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对数阶o-logn"}},[n._v("#")]),n._v(" 对数阶O(logn)：")]),n._v(" "),s("p",[n._v("与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为n ，由于每轮缩减到一半，因此循环次数是 O(log2n) ，即 2^n的反函数。")]),n._v(" "),s("p",[n._v("对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("/* 对数阶（循环实现） */\nint logarithmic(int n) {\n    int count = 0;\n    while (n > 1) {\n        n = n / 2;\n        count++;\n    }\n    return count;\n}\n\n/* 对数阶（递归实现） */\nint logRecur(int n) {\n    if (n <= 1)\n        return 0;\n    return logRecur(n / 2) + 1;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br")])]),s("h3",{attrs:{id:"-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[n._v("#")]),n._v(" "),s("img",{attrs:{src:"https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic.png",alt:"对数阶的时间复杂度"}})]),n._v(" "),s("h3",{attrs:{id:"线性对数阶-o-nlogn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线性对数阶-o-nlogn"}},[n._v("#")]),n._v(" 线性对数阶 O(nlogn)：")]),n._v(" "),s("p",[n._v("线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为  和  。相关代码如下：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("for (int j = 0; j < n; j++){\n    int i = n;\n\n    while(i < n){\n        // 时间复杂度为O(1)的算法\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic_linear.png",alt:"线性对数阶的时间复杂度"}})]),n._v(" "),s("h3",{attrs:{id:"阶乘阶o-n"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阶乘阶o-n"}},[n._v("#")]),n._v(" 阶乘阶O(n!)")]),n._v(" "),s("p",[n._v("阶乘阶对应数学上的“全排列”问题。给定  个互不重复的元素，求其所有可能的排列方案，方案数量为：")]),n._v(" "),s("p",[n._v("阶乘通常使用递归实现。如图 2-14 和以下代码所示，第一层分裂出  个，第二层分裂出  个，以此类推，直至第  层时停止分裂：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("/* 阶乘阶（递归实现） */\nint factorialRecur(int n) {\n    if (n == 0)\n        return 1;\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        count += factorialRecur(n - 1);\n    }\n    return count;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_factorial.png",alt:"阶乘阶的时间复杂度"}})]),n._v(" "),s("h2",{attrs:{id:"_2-3-5-最差、最佳、平均时间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-5-最差、最佳、平均时间复杂度"}},[n._v("#")]),n._v(" 2.3.5   最差、最佳、平均时间复杂度")]),n._v(" "),s("p",[s("strong",[n._v("算法的时间效率往往不是固定的，而是与输入数据的分布有关")]),n._v("。假设输入一个长度为  的数组 "),s("code",[n._v("nums")]),n._v(" ，其中 "),s("code",[n._v("nums")]),n._v(" 由从  至  的数字组成，每个数字只出现一次；但元素顺序是随机打乱的，任务目标是返回元素  的索引。我们可以得出以下结论。")]),n._v(" "),s("ul",[s("li",[n._v("当 "),s("code",[n._v("nums = [?, ?, ..., 1]")]),n._v(" ，即当末尾元素是  时，需要完整遍历数组，"),s("strong",[n._v("达到最差时间复杂度")]),n._v("  。")]),n._v(" "),s("li",[n._v("当 "),s("code",[n._v("nums = [1, ?, ?, ...]")]),n._v(" ，即当首个元素为  时，无论数组多长都不需要继续遍历，"),s("strong",[n._v("达到最佳时间复杂度")]),n._v("  。")])]),n._v(" "),s("p",[n._v("“最差时间复杂度”对应函数渐近上界，使用大  记号表示。相应地，“最佳时间复杂度”对应函数渐近下界，用  记号表示：")]),n._v(" "),s("p",[n._v("最坏时间复杂度 & 平均时间复杂度：")]),n._v(" "),s("blockquote",[s("p",[n._v("最坏时间复杂度是指的是在最坏情况下的时间复杂度，可以保证算法在任何输入情况下都不会比最坏时间复杂度更糟糕。我们通常所说的时间复杂度都是最坏时间复杂度。平均时间复杂度就是从概率的角度，计算所有输入情况下的平均时间。")])]),n._v(" "),s("h3",{attrs:{id:"空间复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度"}},[n._v("#")]),n._v(" 空间复杂度")]),n._v(" "),s("blockquote",[s("p",[n._v("算法的空间复杂度通过计算算法所需的存储空间实现的。和时间复杂度类似，记作：S(n) = O(f(n))，其中 n 为问题的规模，f(n)为关于 n 所占存储空间的函数。")])]),n._v(" "),s("p",[n._v("时间复杂度指的是对运行时间的需求，空间复杂度指的是对运行空间的需求。在实际工作中通常会使用空间换时间的做法，所以我们一般讨论的复杂度都是时间复杂度。")]),n._v(" "),s("p",[n._v("常用数据结构操作复杂度：")]),n._v(" "),s("p",[s("img",{attrs:{src:"https://www.sqlboy.tech/img/data_structure/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E5%A4%8D%E6%9D%82%E5%BA%A6.png",alt:""}})]),n._v(" "),s("p",[n._v("数组排序复杂度：")])])}),[],!1,null,null,null);s.default=e.exports}}]);