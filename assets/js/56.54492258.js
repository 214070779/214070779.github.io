(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{401:function(e,a,s){"use strict";s.r(a);var t=s(4),v=Object(t.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"kvo用法和底层原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kvo用法和底层原理"}},[e._v("#")]),e._v(" KVO用法和底层原理")]),e._v(" "),a("ul",[a("li",[e._v("使用方法：添加观察者，然后怎样实现监听的代理")]),e._v(" "),a("li",[e._v("KVO底层使用了 isa-swizling的技术.")]),e._v(" "),a("li",[e._v("OC中每个对象/类都有isa指针, isa 表示这个对象是哪个类的对象.")]),e._v(" "),a("li",[e._v("当给对象的某个属性注册了一个 observer，系统会创建一个新的中间类（intermediate class）继承原来的class，把该对象的isa指针指向中间类。")]),e._v(" "),a("li",[e._v("然后中间类会重写setter方法，调用setter之前调用willChangeValueForKey, 调用setter之后调用didChangeValueForKey，以此通知所有观察者值发生更改。")]),e._v(" "),a("li",[e._v("重写了 -class 方法，企图欺骗我们这个类没有变，就是原本那个类。")])]),e._v(" "),a("h2",{attrs:{id:"kvo的优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kvo的优缺点"}},[e._v("#")]),e._v(" KVO的优缺点")]),e._v(" "),a("h3",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),a("p",[e._v("1、可以方便快捷的实现两个对象的关联同步，例如view & model")]),e._v(" "),a("p",[e._v("2、能够观察到新值和旧值的变化")]),e._v(" "),a("p",[e._v("3、可以方便的观察到嵌套类型的数据变化")]),e._v(" "),a("h3",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),a("p",[e._v("1、观察对象通过string类型设置，如果写错或者变量名改变，编译时可以通过但是运行时会发生crash")]),e._v(" "),a("p",[e._v("2、观察多个值需要在代理方法中多个if判断")]),e._v(" "),a("p",[e._v("3、忘记移除观察者或重复移除观察者会导致crash")]),e._v(" "),a("h2",{attrs:{id:"怎么手动触发kvo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么手动触发kvo"}},[e._v("#")]),e._v(" 怎么手动触发KVO")]),e._v(" "),a("ul",[a("li",[e._v("KVO机制是通过willChangeValueForKey:和didChangeValueForKey:两个方法触发的。")]),e._v(" "),a("li",[e._v("在观察对象变化前调用willChangeValueForKey:")]),e._v(" "),a("li",[e._v("在观察对象变化后调用didChangeValueForKey:")]),e._v(" "),a("li",[e._v("所以只需要在变更观察值前后手动调用即可。")])]),e._v(" "),a("h2",{attrs:{id:"给kvo添加筛选条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#给kvo添加筛选条件"}},[e._v("#")]),e._v(" 给KVO添加筛选条件")]),e._v(" "),a("ul",[a("li",[e._v("重写automaticallyNotifiesObserversForKey，需要筛选的key返回NO。")]),e._v(" "),a("li",[e._v("setter里添加判断后手动触发KVO"),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code")]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"})])])]),e._v(" "),a("ul",[a("li",[a("p",[e._v('(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {\nif ([key isEqualToString:@"age"]) {')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("  return NO;\n")])])]),a("p",[e._v("}\nreturn [super automaticallyNotifiesObserversForKey:key];\n}\n​")])])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("(void)setAge:(NSInteger)age {\nif (age >= 18) {")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('  [self willChangeValueForKey:@"age"];\n  _age = age;\n  [self didChangeValueForKey:@"age"];\n')])])]),a("p",[e._v("}else {")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("  _age = age;\n")])])]),a("p",[e._v("}\n}")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])])]),e._v(" "),a("h2",{attrs:{id:"使用kvc修改会触发kvo吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用kvc修改会触发kvo吗"}},[e._v("#")]),e._v(" 使用KVC修改会触发KVO吗？")]),e._v(" "),a("p",[e._v("会，只要accessInstanceVariablesDirectly返回YES，通过KVC修改成员变量的值会触发KVO。\n这说明KVC内部调用了willChangeValueForKey:方法和didChangeValueForKey:方法")]),e._v(" "),a("h2",{attrs:{id:"直接修改成员变量会触发kvo吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#直接修改成员变量会触发kvo吗"}},[e._v("#")]),e._v(" 直接修改成员变量会触发KVO吗？")]),e._v(" "),a("p",[e._v("不会")]),e._v(" "),a("h2",{attrs:{id:"kvo的崩溃与防护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kvo的崩溃与防护"}},[e._v("#")]),e._v(" KVO的崩溃与防护")]),e._v(" "),a("p",[e._v("崩溃原因：")]),e._v(" "),a("ul",[a("li",[e._v("KVO 添加次数和移除次数不匹配，大部分是移除多于注册。")]),e._v(" "),a("li",[e._v("被观察者dealloc时仍然注册着 KVO，导致崩溃。")]),e._v(" "),a("li",[e._v("添加了观察者，但未实现 observeValueForKeyPath:ofObject:change:context: 。 防护方案1：")]),e._v(" "),a("li",[e._v("直接使用facebook开源框架KVOController 防护方案2：")]),e._v(" "),a("li",[e._v("自定义一个哈希表，记录观察者和观察对象的关系。")]),e._v(" "),a("li",[e._v("使用fishhook替换 addObserver:forKeyPath:options:context:，在添加前先判断是否已经存在相同观察者，不存在才添加，避免重复触发造成bug。")]),e._v(" "),a("li",[e._v("使用fishhook替换removeObserver:forKeyPath:和removeObserver:forKeyPath:context，移除之前判断是否存在对应关系，如果存在才释放。")]),e._v(" "),a("li",[e._v("使用fishhook替换dealloc，执行dealloc前判断是否存在未移除的观察者，存在的话先移除。")])]),e._v(" "),a("h1",{attrs:{id:"kvc底层原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kvc底层原理"}},[e._v("#")]),e._v(" KVC底层原理")]),e._v(" "),a("h2",{attrs:{id:"setvalue-forkey-的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setvalue-forkey-的实现"}},[e._v("#")]),e._v(" setValue:forKey:的实现")]),e._v(" "),a("ul",[a("li",[e._v("查找setKey:方法和_setKey:方法，只要找到就直接传递参数，调用方法；")]),e._v(" "),a("li",[e._v("如果没有找到setKey:和_setKey:方法，查看accessInstanceVariablesDirectly方法的返回值，如果返回NO（不允许直接访问成员变量），调用setValue:forUndefineKey:并抛出异常NSUnknownKeyException；")]),e._v(" "),a("li",[e._v("如果accessInstanceVariablesDirectly方法返回YES（可以访问其成员变量），就按照顺序依次查找 _key、_isKey、key、isKey 这四个成员变量，如果查找到了就直接赋值；如果没有查到，调用setValue:forUndefineKey:并抛出异常NSUnknownKeyException。")])]),e._v(" "),a("h2",{attrs:{id:"valueforkey-的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#valueforkey-的实现"}},[e._v("#")]),e._v(" valueForKey:的实现")]),e._v(" "),a("ul",[a("li",[e._v("按照getKey，key，isKey的顺序查找方法，只要找到就直接调用；")]),e._v(" "),a("li",[e._v("如果没有找到，accessInstanceVariablesDirectly返回YES（可以访问其成员变量），按照顺序依次查找_key、_isKey、key、isKey 这四个成员变量，找到就取值；如果没有找到成员变量，调用valueforUndefineKey并抛出异常NSUnknownKeyException。")]),e._v(" "),a("li",[e._v("accessInstanceVariablesDirectly返回NO（不允许直接访问成员变量），那么会调用valueforUndefineKey:方法，并抛出异常NSUnknownKeyException；")])])])}),[],!1,null,null,null);a.default=v.exports}}]);