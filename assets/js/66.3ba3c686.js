(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{410:function(s,a,n){"use strict";n.r(a);var _=n(4),t=Object(_.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("GCD 中的 dispatch_once 在面试中是一个比较高频的出现的考察点，这篇文章以面试的角度来回答，为什么 dispatch_once 可以保证只执行一次。")]),s._v(" "),a("p",[s._v("这是一道面试真题，面试官提出了一个问题:")]),s._v(" "),a("p",[a("code",[s._v("dispatch_once")]),s._v(" 为什么可以保证只执行一次？")]),s._v(" "),a("ol",[a("li",[a("code",[s._v("dispatch_once_f")]),s._v(" 实现原理是什么样的？")]),s._v(" "),a("li",[a("code",[s._v("dispatch_once")]),s._v(" 中的原子性操作是怎样的？")]),s._v(" "),a("li",[a("code",[s._v("vval")]),s._v(" 代表什么？ "),a("code",[s._v("DISPATCH_ONCE_DONE")]),s._v(" 又表示什么？")]),s._v(" "),a("li",[s._v("和 "),a("code",[s._v("@synchronized")]),s._v(" 的优劣分析？")])]),s._v(" "),a("p",[s._v("我们以 Q & A 问答的形式来回答面试官的这个问题。")]),s._v(" "),a("h2",{attrs:{id:"为什么可以保证只执行一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么可以保证只执行一次"}},[s._v("#")]),s._v(" 为什么可以保证只执行一次")]),s._v(" "),a("p",[s._v("Q: "),a("code",[s._v("dispatch_once")]),s._v(" 为什么可以保证只执行一次？")]),s._v(" "),a("p",[s._v("A: "),a("code",[s._v("dispatch_once")]),s._v(" 封装并执行了 "),a("code",[s._v("dispatch_once_f")]),s._v(" 函数，其内部使用原子性操作进行标记，以此来配合信号量来决定是否唤醒其他等待的线程，而信号量则用来确保同一时间只有一个线程可以执行回调。")]),s._v(" "),a("h2",{attrs:{id:"dispatch-once-f-实现原理是什么样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-once-f-实现原理是什么样的"}},[s._v("#")]),s._v(" dispatch_once_f 实现原理是什么样的？")]),s._v(" "),a("p",[s._v("为了便于理解，先放上 "),a("code",[s._v("dispatch_once_f")]),s._v(" 的源码")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// Block 数据结构\nstruct Block_layout {\n    // 指向表明该block类型的类\n    void *isa;\n    // 按bit位表示一些 block 的附加信息，比如判断 block 类型、判断 block 引用计数、判断 block 是否需要执行辅助函数等\n    int flags;\n    // 保留变量\n    int reserved;\n    // 函数指针，指向具体的 block 实现的函数调用地址\n    void (*invoke)(void *, ...);\n    struct Block_descriptor *descriptor;\n    /* Imported variables. */\n};\n\n// 宏定义\n// 触发 block 的实现\n#define _dispatch_Block_invoke(bb) \\\n        ((dispatch_function_t)((struct Block_layout *)bb)->invoke)\n\n// 入口方法\nvoid dispatch_once(dispatch_once_t *val, dispatch_block_t block) {\n    dispatch_once_f(val, block, _dispatch_Block_invoke(block));\n}\n\n#define DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)\n\nstruct _dispatch_once_waiter_s {\n    //链表下一个节点\n    volatile struct _dispatch_once_waiter_s *volatile dow_next;\n    // 信号量\n    _dispatch_thread_semaphore_t dow_sema;\n};\n\nvoid dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) {\n  \t// volatileg 关键字编辑的变量 vval\n    // 告诉编译器此指针指向的值随时可能被其他线程改变\n    // 从而使得编译器不对此指针进行代码编译优化\n    struct _dispatch_once_waiter_s * volatile *vval =\n            (struct _dispatch_once_waiter_s**)val;\n    struct _dispatch_once_waiter_s dow = { NULL, 0 };\n    struct _dispatch_once_waiter_s *tail, *tmp;\n  \t// 声明信号变量\n    _dispatch_thread_semaphore_t sema;\n\n    if (dispatch_atomic_cmpxchg(vval, NULL, &dow, acquire)) {\n        _dispatch_client_callout(ctxt, func);\n\n        dispatch_atomic_maximally_synchronizing_barrier();\n        // above assumed to contain release barrier\n        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE, relaxed);\n        tail = &dow;\n        while (tail != tmp) {\n            while (!tmp->dow_next) {\n                dispatch_hardware_pause();\n            }\n            sema = tmp->dow_sema;\n            tmp = (struct _dispatch_once_waiter_s*)tmp->dow_next;\n            _dispatch_thread_semaphore_signal(sema);\n        }\n    } else {\n        dow.dow_sema = _dispatch_get_thread_semaphore();\n        tmp = *vval;\n        for (;;) {\n            if (tmp == DISPATCH_ONCE_DONE) {\n                break;\n            }\n            if (dispatch_atomic_cmpxchgvw(vval, tmp, &dow, &tmp, release)) {\n                dow.dow_next = tmp;\n                _dispatch_thread_semaphore_wait(dow.dow_sema);\n                break;\n            }\n        }\n        _dispatch_put_thread_semaphore(dow.dow_sema);\n    }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br"),a("span",{staticClass:"line-number"},[s._v("49")]),a("br"),a("span",{staticClass:"line-number"},[s._v("50")]),a("br"),a("span",{staticClass:"line-number"},[s._v("51")]),a("br"),a("span",{staticClass:"line-number"},[s._v("52")]),a("br"),a("span",{staticClass:"line-number"},[s._v("53")]),a("br"),a("span",{staticClass:"line-number"},[s._v("54")]),a("br"),a("span",{staticClass:"line-number"},[s._v("55")]),a("br"),a("span",{staticClass:"line-number"},[s._v("56")]),a("br"),a("span",{staticClass:"line-number"},[s._v("57")]),a("br"),a("span",{staticClass:"line-number"},[s._v("58")]),a("br"),a("span",{staticClass:"line-number"},[s._v("59")]),a("br"),a("span",{staticClass:"line-number"},[s._v("60")]),a("br"),a("span",{staticClass:"line-number"},[s._v("61")]),a("br"),a("span",{staticClass:"line-number"},[s._v("62")]),a("br"),a("span",{staticClass:"line-number"},[s._v("63")]),a("br"),a("span",{staticClass:"line-number"},[s._v("64")]),a("br"),a("span",{staticClass:"line-number"},[s._v("65")]),a("br"),a("span",{staticClass:"line-number"},[s._v("66")]),a("br"),a("span",{staticClass:"line-number"},[s._v("67")]),a("br"),a("span",{staticClass:"line-number"},[s._v("68")]),a("br"),a("span",{staticClass:"line-number"},[s._v("69")]),a("br"),a("span",{staticClass:"line-number"},[s._v("70")]),a("br"),a("span",{staticClass:"line-number"},[s._v("71")]),a("br"),a("span",{staticClass:"line-number"},[s._v("72")]),a("br"),a("span",{staticClass:"line-number"},[s._v("73")]),a("br"),a("span",{staticClass:"line-number"},[s._v("74")]),a("br"),a("span",{staticClass:"line-number"},[s._v("75")]),a("br")])]),a("p",[s._v("Q: "),a("code",[s._v("dispatch_once_f")]),s._v(" 实现原理是什么样的？")]),s._v(" "),a("p",[s._v("A: 其内部定义了多个 "),a("code",[s._v("_dispatch_once_waiter_s")]),s._v(" 结构体和一个 "),a("code",[s._v("_dispatch_thread_semaphore_t")]),s._v(" 信号量，通过原子性操作 "),a("code",[s._v("dispatch_atomic_cmpxchg")]),s._v(" 来判断标记值 "),a("code",[s._v("vval")]),s._v(" 是否为 NULL (首次调用 "),a("code",[s._v("dispatch_once")]),s._v(" 时，因为外部传入的 "),a("code",[s._v("dispatch_once_t")]),s._v(" 变量值为 nil，所以 "),a("code",[s._v("vval")]),s._v(" 会为NULL) ，如果为 NULL，则调用 "),a("code",[s._v("_dispatch_client_callout")]),s._v(" 来执行回调，然后在回调执行完成之后，将 "),a("code",[s._v("vval")]),s._v(" 的值更新成 "),a("code",[s._v("DISPATCH_ONCE_DONE")]),s._v(" (表示任务已完成)，最后，对链表的节点进行遍历，并调用 "),a("code",[s._v("_dispatch_thread_semaphore_signal")]),s._v(" 来唤醒等待中的信号量。")]),s._v(" "),a("p",[s._v("因为"),a("code",[s._v("dispatch_atomic_cmpxchg")]),s._v("是原子性操作，所以只有一个线程进入到该逻辑分支中，其他线程会进入另一个分支。")]),s._v(" "),a("p",[s._v("如果不为 NULL 或其他线程同时也调用 "),a("code",[s._v("dispatch_once")]),s._v(" 时，会判断回调是否 "),a("strong",[s._v("已标记完成")]),s._v(" ，如果已完成则跳出循环；否则就是更新链表并调用 "),a("code",[s._v("_dispatch_thread_semaphore_wait")]),s._v(" 阻塞线程，等待回调被标记完成后，再唤醒当前等待的线程。")]),s._v(" "),a("h2",{attrs:{id:"dispatch-once-中的原子性操作是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-once-中的原子性操作是怎样的"}},[s._v("#")]),s._v(" dispatch_once 中的原子性操作是怎样的？")]),s._v(" "),a("p",[s._v("Q: "),a("code",[s._v("dispatch_once")]),s._v(" 中的原子性操作是怎样的?")]),s._v(" "),a("p",[s._v("A: 原子性操作是 "),a("code",[s._v("dispatch_atomic_cmpxchg(vval, NULL, &dow, acquire)")]),s._v(" ，会将 "),a("code",[s._v("$dow")]),s._v(" 赋值给 "),a("code",[s._v("vval")]),s._v(" ，如果 "),a("code",[s._v("vval")]),s._v(" 的初始值为NULL，返回 "),a("code",[s._v("YES")]),s._v(" ,否则返回 "),a("code",[s._v("NO")]),s._v(" 。以及"),a("code",[s._v("dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE)")]),s._v(" 将 "),a("code",[s._v("vval")]),s._v(" 修改为指定状态 "),a("code",[s._v("DISPATCH_ONCE_DONE")]),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"vval-代表什么-dispatch-once-done-又表示什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vval-代表什么-dispatch-once-done-又表示什么"}},[s._v("#")]),s._v(" vval 代表什么？ DISPATCH_ONCE_DONE 又表示什么？")]),s._v(" "),a("p",[s._v("Q: "),a("code",[s._v("vval")]),s._v(" 代表什么？ "),a("code",[s._v("DISPATCH_ONCE_DONE")]),s._v(" 又表示什么？")]),s._v(" "),a("p",[s._v("A: "),a("code",[s._v("vval")]),s._v(" 可以理解为标记值， "),a("code",[s._v("DISPATCH_ONCE_DONE")]),s._v(" 用来标记回调是否已完成，以此来决定是否要唤起信号量来解除线程的阻塞。")]),s._v(" "),a("h2",{attrs:{id:"和-synchronized-的优劣分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#和-synchronized-的优劣分析"}},[s._v("#")]),s._v(" 和 @synchronized 的优劣分析？")]),s._v(" "),a("p",[s._v("Q: 和 "),a("code",[s._v("@synchronized")]),s._v(" 的优劣分析？")]),s._v(" "),a("p",[s._v("A: 相比之下 "),a("code",[s._v("dispatch_once")]),s._v(" 的性能更高，速度更快，并且针对处理器进行了优化。两者分别利用来不同的方式来保证线程安全， "),a("code",[s._v("@synchronized")]),s._v(" 采用的是递归互斥锁的方式来保证线程安全，而 "),a("code",[s._v("dispatch_once")]),s._v(" 是使用原子操作来代替锁，使用信号量来保证线程同步。")])])}),[],!1,null,null,null);a.default=t.exports}}]);