(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{454:function(t,s,a){"use strict";a.r(s);var v=a(4),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"面向对象开发核心-向协议开发核心"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向对象开发核心-向协议开发核心"}},[t._v("#")]),t._v(" 面向对象开发核心&& 向协议开发核心")]),t._v(" "),s("p",[t._v("面向对象开发核心是: 封装-继承-(多态),弊端：继承链很长，代码高度耦合\n面向协议开发核心是: 模块化(组件化)")]),t._v(" "),s("p",[t._v("OC不能面向协议开发的原因是，OC中的协议只能有方法的声明，不能有方法的实现，而Swift可以通过协议拓展，来声明方法和实现方法，所以swift可以进行面向协议编程。")]),t._v(" "),s("div",{staticClass:"language-objectivec line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[t._v("protocol Emitterable "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//协议拓展")]),t._v("\nextension Emitterable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// 方法的声明和实现")]),t._v("\n    func "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("start")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("面向协议开发应用:")]),t._v(" "),s("p",[t._v("很多UIView会通过xib进行描述, 而我们经常需要从一个xib中加载UIView, 抽取单独的协议, 需要从xib中加载类, 只需要遵守协议即可，而不需要继承自父类，再转为子类。")]),t._v(" "),s("p",[t._v("使用loadFromNib方法，从xib中加载UIView,")]),t._v(" "),s("div",{staticClass:"language-objectivec line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[t._v("protocol NibLoadable "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nextension NibLoadable where Self "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" UIView "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" func "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("loadFromNib")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_ nibname "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" String"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nil"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" Self "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        let loadName "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nibname "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" nil "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\(self)"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nibname"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Bundle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("loadNibNamed")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("loadName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" owner"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nil"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" nil"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("first as"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v(" Self\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("p",[t._v("一般会使用where Self对可遵守协议的类型进行限制。此处UIView要求的子类才可遵守该协议，并且可以直接使用UIView相关的属性和方法。")]),t._v(" "),s("h2",{attrs:{id:"swift和oc的主要区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#swift和oc的主要区别"}},[t._v("#")]),t._v(" swift和OC的主要区别：")]),t._v(" "),s("p",[t._v("OC面向对像编程，swift面向协议编程\nOC 中协议主要用来对象件传值，swift 不仅可以用来传值还可以定义属性方法，支持拓展")]),t._v(" "),s("h3",{attrs:{id:"口语回答"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#口语回答"}},[t._v("#")]),t._v(" 口语回答")]),t._v(" "),s("p",[t._v('swift 不分 .h 和 .m ，只有一个 .swift 文件，文件的数量和后缀与 OC 不同\nswift引入了命名空间，从此不用再import其他文件\nswift 语言代码语句后不需要加";"\nswift 语言比较简短简洁\nswift 定义变量或常量使用 var 或 let\n字符串，swift “”，OC @“”\nswitch 语句，swift 可以是各种数据类型，OC 中的switch语句，不能判断对象类型, 只能判断基本类型中的整数\n判断语句 if let，gurad\n可选（Optional）类型。swift增加了可选类型处理值缺失的情况。nil的含义不同，可选类型比 Objective-C 中的 nil 指针更加安全。\nOC 中定义的类，都是直接或者间接继承NSObject类的，swift 可以直接定义一个基类，不继承任何类\nswift元祖类型，支持运算符重载\nswift支持泛型，OC只支持轻量泛型\nswift函数嵌套\nswift的协议不仅可以被类实现，还可以被struct和enum实现\nswift是静态语言，OC是动态语言。\nswift偏重于面向协议的编程，OC面向对象编程。\nswift注重值类型，OC注重引用类型。\nswift支持函数式编程')]),t._v(" "),s("h3",{attrs:{id:"oc与swift的区别一-文件结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#oc与swift的区别一-文件结构"}},[t._v("#")]),t._v(" OC与Swift的区别一(文件结构)")]),t._v(" "),s("ol",[s("li",[t._v("文件后缀名")])]),t._v(" "),s("p",[t._v("oc的文件后缀名为：头文件.h  主体文件.m")]),t._v(" "),s("p",[t._v("swift文件后缀名为：.swift")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("代码分隔符")])]),t._v(" "),s("p",[t._v("oc中使用分号;作为代码分隔符")]),t._v(" "),s("p",[t._v("swift中无需使用代码分隔符，以行作为代码分隔，如一行内有多行代码，则各行代码之间同样需使用分号;分隔")]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("main函数")])]),t._v(" "),s("p",[t._v("oc的main函数为程序入口，其函数定义与c语言类似")]),t._v(" "),s("p",[t._v("swift没有main函数，其代码是至上而下运行，第一行代码即为程序入口")]),t._v(" "),s("p",[t._v("不像C语言和OC语言一样都必须有一个主函数main()作为程序的入口，swift程序从第一句开始向下顺序执行，一直到最后。(swift将全局范围内的首句可执行代码作为程序入口，swift也有main函数，只是不用我们自己编写。)")]),t._v(" "),s("h2",{attrs:{id:"oc与swift的区别一-常量、变量、运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#oc与swift的区别一-常量、变量、运算符"}},[t._v("#")]),t._v(" OC与Swift的区别一(常量、变量、运算符)")]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[t._v("常量与变量声明")])]),t._v(" "),s("p",[t._v("oc的变量声明使用  类型 变量名 ＝ 变量值的方式，其中类型为系统内置数据类型或自定义类型，变量名需由英文字母开头且不能包含特殊字符")]),t._v(" "),s("p",[t._v("swift变量声明使用 var 变量名 ＝ 变量值的方式，其中变量名可以使用任何你喜欢的字符，甚至是表情符号emoji等")]),t._v(" "),s("p",[t._v('oc常量声明使用const放在变量定义前即为声明常量，如：const NSString *str = @"Hello";')]),t._v(" "),s("p",[t._v("swift常量声明使用 let 常量名 ＝ 常量值的方式，同样可以使用任何你喜欢的字符作为常量名")]),t._v(" "),s("p",[t._v("swift 可以自动推断出常量与变量的数据类型，当然也可以使用“：数据类型”的方式指定其具体数据类型，如 let age:Int = 10")]),t._v(" "),s("p",[t._v("PS:swift严格要求变量在使用前必须进行初始化，如上所示，必须给定变量值，而oc则不强制")]),t._v(" "),s("ol",{attrs:{start:"5"}},[s("li",[t._v("整数")])]),t._v(" "),s("p",[t._v("swift提供了8、16、32、64位有符号和无符号整数，如UInt8、Int64等，每一种类型都有一个min和max可调用，如UInt8.min、UInt8.max等。")]),t._v(" "),s("ol",{attrs:{start:"6"}},[s("li",[t._v("浮点数")])]),t._v(" "),s("p",[t._v("swift浮点数可以用十进制和十六进制2种进制来表示")]),t._v(" "),s("p",[t._v("十进制：let d1=12.5或let d2=0.125e2 后缀e2代表e前面部分乘以10的2次方")]),t._v(" "),s("p",[t._v("十六进制：let d3=0xC.8p0    0x前缀表示后面是十六进制，p0代表前面整个数字乘以2的0次方  且指数部分（px）必须存在")]),t._v(" "),s("ol",{attrs:{start:"7"}},[s("li",[t._v("数字格式")])]),t._v(" "),s("p",[t._v("swift中允许在数字中间加入符号_，以增加可读性，并不会影响原来数据，如 let money ＝ 100_0000 还是表示100000")]),t._v(" "),s("p",[t._v("swift中还允许在数字前面加入0，以增加可读性，并不会影响原来数据，如 let money = 001_000_000还是表示1000000")]),t._v(" "),s("p",[t._v("而这些在oc中是不允许的")]),t._v(" "),s("ol",{attrs:{start:"8"}},[s("li",[t._v("字符串")])]),t._v(" "),s("p",[t._v('oc中使用@""来表示字符串')]),t._v(" "),s("p",[t._v('swift使用""来表示字符串，拼接字符串直接使用＋将两个字符串或字符串变量进行拼接运算即可，如var str1="abc";var str2="def";var str3=str1+str2;')]),t._v(" "),s("p",[t._v("oc使用stringFormat方法进行字符串格式化，可以将其他非字符串值插入字符串中进行格式化")]),t._v(" "),s("p",[t._v('swift使用“()”将其它非字符串插入字符串中，如：let hand=2;var age=20;let str="我今年(age)岁了，有(hand)只手"，也可以使用String(age)进行转换，并用＋进行字符串拼接，如let str="我今年"＋String(age)+"岁了，有"+String(hand)+"只手"')]),t._v(" "),s("ol",{attrs:{start:"9"}},[s("li",[t._v("数据类型转换")])]),t._v(" "),s("p",[t._v("swift类型转换使用“数据类型(原数据)”进行类型转换，如let money1=100;let money2=50.5;let totalMoney=Double(money1)+money2;")]),t._v(" "),s("ol",{attrs:{start:"10"}},[s("li",[t._v("运算符")])]),t._v(" "),s("p",[t._v("oc赋值运算符返回该变量值，如 int a ＝ 0；int b ＝ a ＝ 10；其实a＝10返回10赋值给了b")]),t._v(" "),s("p",[t._v("swift赋值运算符没有返回值")]),t._v(" "),s("p",[t._v("oc求模运算只支持整数求模运算")]),t._v(" "),s("p",[t._v("swift求模运算支持浮点数求模运算，如8%2.5=0.5，因为8=2.5*3+0.5")]),t._v(" "),s("p",[t._v("oc中bool有两个值 YES  NO  其实根本0为假，非0都代表真")]),t._v(" "),s("p",[t._v("swift中bool有两个值false true   且只有false和true   0与非0在任何场合都不代表bool值，比如if(10)这种写法是错的")]),t._v(" "),s("p",[t._v("swift 比oc中多几种运算符")]),t._v(" "),s("ol",{attrs:{start:"10"}},[s("li",[t._v("1闭合范围运算符")])]),t._v(" "),s("p",[t._v("a...b [a，b]包含a，b")]),t._v(" "),s("p",[t._v("a..<b [a，b)包含a，不包含b")]),t._v(" "),s("p",[t._v("如for i in 0..<5{")]),t._v(" "),s("p",[t._v("printfln(i)")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("ol",{attrs:{start:"10"}},[s("li",[t._v("2溢出运算符")])]),t._v(" "),s("p",[t._v("swift为整型计算提供了5个&开头的溢出运算符")]),t._v(" "),s("p",[t._v("&+ 溢出加")]),t._v(" "),s("p",[t._v("&- 溢出减")]),t._v(" "),s("p",[t._v("&* 溢出乘")]),t._v(" "),s("p",[t._v("&/ 溢出除")]),t._v(" "),s("p",[t._v("&% 溢出求模")]),t._v(" "),s("p",[t._v("如 let x = UInt8.max //x=255")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("let y = x &+1         //y=0\n")])])]),s("p",[t._v("如 let x = UInt8.min //x=0")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("let y = y &- 1      //y=255\n")])])]),s("h3",{attrs:{id:"oc与swift的区别三-条件语句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#oc与swift的区别三-条件语句"}},[t._v("#")]),t._v(" OC与Swift的区别三(条件语句)")]),t._v(" "),s("ol",{attrs:{start:"11"}},[s("li",[t._v("swift中的switch结构")])]),t._v(" "),s("p",[t._v("区别一：")]),t._v(" "),s("p",[t._v("oc中switch条件只可以放整数")]),t._v(" "),s("p",[t._v("swift中switch条件可以放几乎任何数据类型")]),t._v(" "),s("p",[t._v("区别二：")]),t._v(" "),s("p",[t._v("oc中每一个case中应有break，如果没有break，则会继续向下贯穿执行case直到碰见break跳出switch结构")]),t._v(" "),s("p",[t._v("swift中不需要在case分支最后添加break语句，该case分支执行完成后，会跳出switch结构")]),t._v(" "),s("p",[t._v("区别三：")]),t._v(" "),s("p",[t._v("oc中不是每个case后面必须有可执行语句，如果某个case分支中没有可执行语句和break，则该分支将会执行其下面最近的一个有可执行语句的分支中代码，以此实现多条件匹配")]),t._v(" "),s("p",[t._v("swift中每个case后面必须都有可执行语句，")]),t._v(" "),s("p",[t._v("ps：此区别是因为区别二的存在，swift中表示多条件匹配的情况使用的语法为，case后跟多个条件，用逗号隔开。")]),t._v(" "),s("p",[t._v("此外，swift的case中可以填写一个范围作为匹配条件，如case a...b:")]),t._v(" "),s("p",[t._v("区别三：")]),t._v(" "),s("p",[t._v("oc中switch中default不是必需的")]),t._v(" "),s("p",[t._v("swift中switch中default是必需的")]),t._v(" "),s("p",[t._v("swift中switch语句可以使用where来增加判断条件")]),t._v(" "),s("p",[t._v("如：")]),t._v(" "),s("p",[t._v("var point = (10,-10)")]),t._v(" "),s("p",[t._v("switch point{")]),t._v(" "),s("p",[t._v("case let(x,y) where x == y :")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("         //\n\n  case let(x,y) where x == -y :\n\n        //\n\n   default :\n")])])]),s("p",[t._v("//")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("swift中switch语句可以使用fallthrough关键字来执行贯穿操作，即执行完当前case后，会接着执行fallthrough后面的case活着default语句，类似于oc中case没有写break语句，但是使用了fallthrough，其后面的case条件中将不能定义常量或变量，即fallthrough后面的case条件不能使用类似上面代码中let (x,y) 这样的变量来接收point，否则会有语法错误。")]),t._v(" "),s("h3",{attrs:{id:"oc与swift的区别四-条件语句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#oc与swift的区别四-条件语句"}},[t._v("#")]),t._v(" OC与Swift的区别四(条件语句)")]),t._v(" "),s("p",[t._v("12.条件语句的区别，此处只写区别，没有指出区别的其他方面oc与swift基本一致")]),t._v(" "),s("p",[t._v("12.1")]),t._v(" "),s("p",[t._v("oc中for if switch语句体如果只有一行代码，则{}可以省略")]),t._v(" "),s("p",[t._v("swift中for if switch语句体必须使用{} ，否则有语法错误")]),t._v(" "),s("p",[t._v("12.2for-in语法的区别：")]),t._v(" "),s("p",[t._v("//从1循环到3，包括3，即循环3次")]),t._v(" "),s("p",[t._v("for i in 1...3{")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("//如果不需要用到循环条件范围中的值，则使用_忽略该循环条件值，使其在循环体内不会创建局部变量")]),t._v(" "),s("p",[t._v("for _ in 1...3{")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("//循环条件值是常量，在循环体内不能改变")]),t._v(" "),s("p",[t._v("for i in 1...3{")]),t._v(" "),s("p",[t._v("i = 10 　　//此代码报错")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("h3",{attrs:{id:"oc与swift的区别五-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#oc与swift的区别五-函数"}},[t._v("#")]),t._v(" OC与Swift的区别五(函数)")]),t._v(" "),s("p",[t._v("13 函数")]),t._v(" "),s("p",[t._v("oc函数定义：")]),t._v(" "),s("p",[t._v("返回值类型 函数名(参数类型 参数名,参数类型 参数名){")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("swift 函数定义：")]),t._v(" "),s("p",[t._v("func 函数名(参数名:参数类型,参数名:参数类型) -> 返回值类型{")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("swift中没有返回值的函数有三种写法:")]),t._v(" "),s("p",[t._v("13.1")]),t._v(" "),s("p",[t._v("func 函数名(参数名:参数类型,参数名:参数类型) -> Void{")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("13.2")]),t._v(" "),s("p",[t._v("func 函数名(参数名:参数类型,参数名:参数类型) -> (){")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("13.3")]),t._v(" "),s("p",[t._v("func 函数名(参数名:参数类型,参数名:参数类型){")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("swift中没有行参的函数函数名后面的小括号也不能省略")]),t._v(" "),s("p",[t._v("返回元组的函数定义：")]),t._v(" "),s("p",[t._v("func 函数名(参数名:参数类型,参数名:参数类型) -> (元素名称:元素类型,元素名称:元素类型){")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("swift中的外部参数名")]),t._v(" "),s("p",[t._v("func 函数名(外部参数名 形式参数名:参数类型,外部参数名 形式参数名:参数类型) -> 返回值类型{")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("//形式参数名前面加上# ，则外部参数名与形式参数名相同")]),t._v(" "),s("p",[t._v("func 函数名(#形式参数名:参数类型,#形式参数名:参数类型) -> 返回值类型{")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("当调用增加了外部参数名的函数，在调用时，则编译器会自动生成带有外部参数名的调用，并且外部参数名在调用时必须加上且参数顺序必须与定义时一致，这样可以增加调用者对参数的可读性")]),t._v(" "),s("p",[t._v("如")]),t._v(" "),s("p",[t._v("func addPerson(person_name:String,person_age:Int){")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v('addPerson(person_name:"jack",person_age:28)')]),t._v(" "),s("p",[t._v("swift中的默认参数值")]),t._v(" "),s("p",[t._v("func 函数名(外部参数名 形式参数名:参数类型 = 参数默认值,外部参数名 形式参数名:参数类型) -> 返回值类型{")]),t._v(" "),s("p",[t._v("}")]),t._v(" "),s("p",[t._v("带有默认值的函数调用时，有默认值的参数可以不传值，且如果不指定有默认值行参的外部参数名，swift会自动生成一个与其行参名相同的外部参数名，在有默认值的行参参数名前加上_，则调用时不需要写其外部参数名")]),t._v(" "),s("p",[t._v("注意： oc中参数在函数体内是可以修改其值的，因为其作用类似于局部变量。但是在swift中，参数默认都是常量参数，不能在函数体内修改参数值。如果需要在函数体内修改参数值，则需要定义变量参数，即在参数名前加var关键字即可。")])])}),[],!1,null,null,null);s.default=_.exports}}]);