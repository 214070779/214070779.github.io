(window.webpackJsonp=window.webpackJsonp||[]).push([[301],{648:function(e,n,t){"use strict";t.r(n);var o=t(4),r=Object(o.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"app的内存占用情况是如何检测出来的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#app的内存占用情况是如何检测出来的"}},[e._v("#")]),e._v(" APP的内存占用情况是如何检测出来的")]),e._v(" "),n("h2",{attrs:{id:"webview为何不能用app的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webview为何不能用app的"}},[e._v("#")]),e._v(" webview为何不能用app的")]),e._v(" "),n("p",[e._v("历史原因：")]),e._v(" "),n("p",[e._v("早期 UIWebView 由于与 app 共享内存空间， 会容易导致app/浏览器卡顿、白屏、甚至崩溃，甚至 input 传个大图/文件如果处理不当就直接崩；之后 WKWebView 虽然优化了 WebView 内存及管理，但仍存在很多bug，加上 iPhone 本身内存空间较小，综合起来还是容易出现卡顿、白屏、甚至崩溃问题；")]),e._v(" "),n("p",[e._v("WKWebview 会开辟进程(不是线程)来处理任务；")]),e._v(" "),n("p",[e._v("开辟的进程包括一个 content 的渲染进程和一个 networking 的网络处理进程； WKWebview 开辟的进程如果在内\n存超过预算之后，使用 WKWebview 的当前 app 并不会被杀掉，最多就是 WKWebview 展示的页面变成空白页；")]),e._v(" "),n("p",[e._v("WKWebview 开启进程所占用的内存虽然不会影响当前 app，但是毕竟 iOS 中使用的是共享物理内存，当占用内存过大时，必定会影响到 app 的执行效率。如果 WKWebview 没有及时销毁，甚至会发生 CPU 抢占的现象，加剧原 APP 的效率问题；")]),e._v(" "),n("p",[e._v("但要注意，iOS 现在 App 基本会用 WKWebView，这种情况下客户端是拿不到页面（WebView）的内存信息的（因为系统共享 WebView 虚拟内存），因此像 DoraemonKit 的内存模块也是无法观察页面内存情况，这时候的方案就是获取整个设备的内存信息，通过观察设备内存变化来进行判断，缺点就是难以保证其他应用及系统的影响；")]),e._v(" "),n("p",[e._v("FBMemoryProfiler则可以检测所有类型的内存泄漏，原理是hook了系统的alloc和dealloc函数，跟instruments的功能类似，只不过更加轻量化，可以在APP运行时实时看到内存分配的情况，如果有对象内存泄漏，则会标红表示。")]),e._v(" "),n("p",[e._v("uint64_t FBMemoryProfilerResidentMemoryInBytes() {\nkern_return_t rval = 0;\nmach_port_t task = mach_task_self();")]),e._v(" "),n("p",[e._v("struct task_basic_info info = {0};\nmach_msg_type_number_t tcnt = TASK_BASIC_INFO_COUNT;\ntask_flavor_t flavor = TASK_BASIC_INFO;")]),e._v(" "),n("p",[e._v("task_info_t tptr = (task_info_t) &info;")]),e._v(" "),n("p",[e._v("if (tcnt > sizeof(info))\nreturn 0;")]),e._v(" "),n("p",[e._v("rval = task_info(task, flavor, tptr, &tcnt);\nif (rval != KERN_SUCCESS) {\nreturn 0;\n}")]),e._v(" "),n("p",[e._v("return info.resident_size;\n}")]),e._v(" "),n("p",[e._v("DoraemonKit 可能使用了一些与 Instruments 类似的技术来监测应用的内存占用情况。一种常见的方法是使用 Objective-C 运行时（Objective-C Runtime）来动态地获取对象的信息，包括对象的内存占用情况。通过追踪对象的创建和释放，可以估算应用在运行时的内存占用。")]),e._v(" "),n("ul",[n("li",[e._v("(NSInteger)useMemoryForApp{\ntask_vm_info_data_t vmInfo;\nmach_msg_type_number_t count = TASK_VM_INFO_COUNT;\nkern_return_t kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &vmInfo, &count);\nif(kernelReturn == KERN_SUCCESS)\n{\nint64_t memoryUsageInByte = (int64_t) vmInfo.phys_footprint;\nreturn (NSInteger)(memoryUsageInByte/1024/1024);\n}\nelse\n{\nreturn -1;\n}\n}")])]),e._v(" "),n("p",[e._v("YYAppPerformanceMonitor")]),e._v(" "),n("p",[e._v("YYMemoryUsage memory_usage() {\n// 由内核提供的关于该进程的内存信息，包括虚拟内存，常驻内存，物理内存，最大常驻内存等\nstruct mach_task_basic_info info;\nmach_msg_type_number_t count = sizeof(info) / sizeof(integer_t);\nif (task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &count) == KERN_SUCCESS) {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    YYMemoryUsage usage;\n    usage.has_usage = info.resident_size / MEMORY_SIZE_PER_MB;\n    usage.total = [NSProcessInfo processInfo].physicalMemory / MEMORY_SIZE_PER_MB;\n    usage.ratio = (double)info.resident_size / (double)[NSProcessInfo processInfo].physicalMemory * 100;\n    return usage;\n}\nreturn (YYMemoryUsage){ 0 };\n")])])]),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("创建了一个定时器，每隔0.5s从内核中读取该进程的内存信息\n从内核中读取该进程的内存信息\n// 由内核提供的关于该进程的内存信息，包括虚拟内存，常驻内存，物理内存，最大常驻内存等")]),e._v(" "),n("p",[e._v("检测webvew的内存有两种")]),e._v(" "),n("p",[e._v("1.使用instrument检测webvew的内存\n2.在webview中显示内存使用的情况")]),e._v(" "),n("p",[e._v("// YourViewController.h\n#import <UIKit/UIKit.h>\n#import <WebKit/WebKit.h>")]),e._v(" "),n("p",[e._v("@interface YourViewController : UIViewController "),n("WKScriptMessageHandler")],1),e._v(" "),n("p",[e._v("@property (nonatomic, strong) WKWebView *webView;")]),e._v(" "),n("p",[e._v("@end")]),e._v(" "),n("p",[e._v('// YourViewController.m\n#import "YourViewController.h"')]),e._v(" "),n("p",[e._v("@implementation YourViewController")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("(void)viewDidLoad {\n[super viewDidLoad];")]),e._v(" "),n("p",[e._v('WKUserContentController *userContentController = [[WKUserContentController alloc] init];\n[userContentController addScriptMessageHandler:self name:@"memoryUsage"];')]),e._v(" "),n("p",[e._v("WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];\nconfiguration.userContentController = userContentController;")]),e._v(" "),n("p",[e._v("self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:configuration];\n[self.view addSubview:self.webView];")]),e._v(" "),n("p",[e._v('NSString *htmlString = @"')]),n("html",[n("head",[n("script",[e._v("window.webkit.messageHandlers.memoryUsage.postMessage({totalMemory: performance.memory.totalJSHeapSize, usedMemory: performance.memory.usedJSHeapSize});")])]),n("body")]),e._v('";\n[self.webView loadHTMLString:htmlString baseURL:nil];\n}'),n("p")]),e._v(" "),n("li",[n("p",[e._v('(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {\nif ([message.name isEqualToString:@"memoryUsage"]) {\nNSDictionary *memoryInfo = message.body;\n// 处理从 JavaScript 传递过来的内存信息\nNSLog(@"Total Memory: %@, Used Memory: %@", memoryInfo[@"totalMemory"], memoryInfo[@"usedMemory"]);\n}\n}')])])]),e._v(" "),n("p",[e._v("@end")])])}),[],!1,null,null,null);n.default=r.exports}}]);