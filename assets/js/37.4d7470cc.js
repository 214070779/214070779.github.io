(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{381:function(n,s,a){"use strict";a.r(s);var i=a(4),e=Object(i.a)({},(function(){var n=this,s=n._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("p",[n._v("Objective-C 有两个神奇的方法：+load 和 +initialize，这两个方法在类被使用时会自动调用。但是两个方法的不同点会导致应用层面上性能的显著差异。")]),n._v(" "),s("p",[n._v("小结：")]),n._v(" "),s("h4",{attrs:{id:"_1、相同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、相同点"}},[n._v("#")]),n._v(" 1、相同点")]),n._v(" "),s("p",[n._v("1).load和initialize会被自动调用，不能手动调用它们。"),s("br"),n._v("\n2).子类实现了load和initialize的话，会隐式调用父类的load和initialize方法。"),s("br"),n._v("\n3).load和initialize方法内部使用了锁，因此它们是线程安全的。")]),n._v(" "),s("h4",{attrs:{id:"_2、不同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、不同点"}},[n._v("#")]),n._v(" 2、不同点")]),n._v(" "),s("p",[n._v("1).调用顺序不同，")]),n._v(" "),s("ol",[s("li",[n._v("以main函数为分界，"),s("code",[n._v("+load")]),n._v("方法在main函数之前执行，")]),n._v(" "),s("li",[s("code",[n._v("+initialize")]),n._v("在main函数之后执行。")])]),n._v(" "),s("p",[n._v("2).若自身未定义，是否沿用父类的方法：")]),n._v(" "),s("ol",[s("li",[n._v("子类中没有实现"),s("code",[n._v("+load")]),n._v("方法的话，不会调用父类的"),s("code",[n._v("+load")]),n._v("方法；（不会）")]),n._v(" "),s("li",[n._v("而子类如果没有实现"),s("code",[n._v("+initialize")]),n._v("方法的话，也会自动调用父类的"),s("code",[n._v("+initialize")]),n._v("方法。（会）")])]),n._v(" "),s("p",[n._v("3).调用时机：")]),n._v(" "),s("ol",[s("li",[s("code",[n._v("+load")]),n._v("方法是在类被装载进来的时候就会调用，")]),n._v(" "),s("li",[s("code",[n._v("+initialize")]),n._v("在第一次给某个类发送消息时调用（比如实例化一个对象），并且只会调用一次，是懒加载模式，如果这个类一直没有使用，就不回调用到"),s("code",[n._v("+initialize")]),n._v("方法。")])]),n._v(" "),s("p",[n._v("4).调用方式：")]),n._v(" "),s("ol",[s("li",[s("em",[n._v("load是根据函数地址直接调用")])]),n._v(" "),s("li",[s("em",[n._v("initialize是通过objc_msgSend调用")])])]),n._v(" "),s("table",[s("thead",[s("tr",[s("th",[n._v("方法")]),n._v(" "),s("th",[n._v("+(void)load")]),n._v(" "),s("th",[n._v("+(void)initialize")])])]),n._v(" "),s("tbody",[s("tr",[s("td",[n._v("执行时机")]),n._v(" "),s("td",[n._v("在程序运行后立即执行")]),n._v(" "),s("td",[n._v("在类的方法第一次被调时执行")])]),n._v(" "),s("tr",[s("td",[n._v("若自身未定义，是否沿用父类的方法？")]),n._v(" "),s("td",[n._v("否(这是"),s("strong",[n._v("由于+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用")]),n._v("。)")]),n._v(" "),s("td",[n._v("是")])]),n._v(" "),s("tr",[s("td",[n._v("分类中的定义")]),n._v(" "),s("td",[n._v("全都执行，但后于类中的方法 覆盖类中的方法，")]),n._v(" "),s("td",[n._v("只执行一个")])]),n._v(" "),s("tr",[s("td",[n._v("执行次数（非主动调用的情况下）")]),n._v(" "),s("td",[n._v("必然一次")]),n._v(" "),s("td",[n._v("0、1、多 次（调用者会不同）")])])])]),n._v(" "),s("p",[n._v("先看"),s("a",{attrs:{href:"https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Fdocumentation%2Fobjectivec%2Fnsobject%3Flanguage%3Dobjc",target:"_blank",rel:"noopener noreferrer"}},[n._v("官方解释"),s("OutboundLink")],1),n._v("：")]),n._v(" "),s("ol",[s("li",[s("p",[n._v("首先说一下 + initialize 方法：苹果官方对这个方法有这样的一段描述：这个方法会在 "),s("em",[s("strong",[n._v("第一次初始化这个类之前")])]),n._v(" 被调用，我们用它来初始化静态变量。")])]),n._v(" "),s("li",[s("p",[n._v("load 方法会在加载类的时候就被调用，也就是 ios 应用启动的时候，就会加载所有的类，就会调用每个类的 + load 方法。")])]),n._v(" "),s("li",[s("p",[n._v("之后我们结合代码来探究一下 + initialize 与 + load 两个方法的调用时机，首先是 "),s("em",[s("strong",[n._v("+ load")])]),n._v("：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('#pragram ---main函数中的代码---\n#import <UIKit/UIKit.h>\n#import "AppDelegate.h"\nint main(int argc, char * argv[]) {\n    NSLog(@"%s",__func__);\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n#pragram ---基于NSObject的Person类---\n#import "Person.h"\n@implementation Person\n + (void)load{\n    NSLog(@"%s",__func__);\n}\n + (void)initialize{\n    [super initialize];\n    NSLog(@"%s %@",__func__,[self class]);\n}\n - (instancetype)init{\n    if (self = [super init]) {\n        NSLog(@"%s",__func__);\n    }\n    return self;\n}\n@end\n#pragram ---基于Person的Son类---\n#import "Girl.h"\n@implementation Girl\n + (void)load{\n    NSLog(@"%s ",__func__);\n}\n + (void)initialize{\n    [super initialize];\n    NSLog(@"%s ",__func__);\n}\n - (instancetype)init{\n    if (self = [super init]) {\n        NSLog(@"%s",__func__);\n    }\n    return self;\n}\n@end\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br")])])])]),n._v(" "),s("p",[n._v("运行程序，我们看一下输出日志：")]),n._v(" "),s("div",{staticClass:"language-2015-10-27 line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("2015-10-27 15:21:07.545 initialize[11637:334237] +[Person load]\n2015-10-27 15:21:07.546 initialize[11637:334237] +[Girl load] \n2015-10-27 15:21:07.546 initialize[11637:334237] main\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("h3",{attrs:{id:"二、接下来我们来查看一下-initialize-方法-先在-viewcontroller-中创建-person-和-girl-对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、接下来我们来查看一下-initialize-方法-先在-viewcontroller-中创建-person-和-girl-对象"}},[n._v("#")]),n._v(" 二、接下来我们来查看一下 "),s("em",[s("strong",[n._v("+ initialize")])]),n._v(" 方法，先在 ViewController 中创建 Person 和 Girl 对象：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('#import "ViewController.h"\n#import "Person.h"\n#import "Son.h"\n#import "Girl.h"\n@interface ViewController ()\n@end\n@implementation ViewController\n - (void)viewDidLoad {\n    [super viewDidLoad];\n    Person * a = [Person new];\n    Person * b = [Person new];\n    Girl *c = [Girl new];\n    Girl *d = [Girl new];\n}\n@end\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br")])]),s("p",[n._v("下面我们来看一下输出日志：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("2015-10-27 15:33:56.195 initialize[11711:342410] +[Person load]\n2015-10-27 15:33:56.196 initialize[11711:342410] +[Girl load] \n2015-10-27 15:33:56.197 initialize[11711:342410] main\n2015-10-27 15:33:56.259 initialize[11711:342410] +[Person initialize] Person\n2015-10-27 15:33:56.259 initialize[11711:342410] -[Person init]\n2015-10-27 15:33:56.259 initialize[11711:342410] -[Person init]\n2015-10-27 15:33:56.259 initialize[11711:342410] +[Girl initialize] \n2015-10-27 15:33:56.260 initialize[11711:342410] -[Girl init]\n2015-10-27 15:33:56.260 initialize[11711:342410] -[Girl init]\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br")])]),s("p",[n._v("通过这个实验我们可以确定两点："),s("br"),n._v("\n- "),s("strong",[n._v("+ initialize")]),n._v(" 方法类似一个懒加载，如果没有使用这个类，那么系统默认不会去调用这个方法，且默认只加载一次；"),s("br"),n._v("\n- "),s("strong",[n._v("+ initialize")]),n._v(" 的调用发生在 +init 方法之前。")]),n._v(" "),s("h3",{attrs:{id:"三、接下来再探究一下-initialize-在父类与子类之间的关系-创建一个继承自-person-类的-son类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、接下来再探究一下-initialize-在父类与子类之间的关系-创建一个继承自-person-类的-son类"}},[n._v("#")]),n._v(" 三、接下来再探究一下 "),s("em",[s("strong",[n._v("+ initialize")])]),n._v(" 在父类与子类之间的关系，创建一个继承自 Person 类的 Son类：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('#pragram ---ViewController 中的代码---\n#import "ViewController.h"\n#import "Person.h"\n#import "Son.h"\n#import "Girl.h"\n@interface ViewController ()\n@end\n@implementation ViewController\n - (void)viewDidLoad {\n    [super viewDidLoad];\n    Person * a = [Person new];\n    Person * b = [Person new];\n    Son*z = [Son new];\n}\n@end\n\n\n2015-10-27 15:44:55.762 initialize[12024:351576] +[Person load]\n2015-10-27 15:44:55.764 initialize[12024:351576] +[Son load]\n2015-10-27 15:44:55.764 initialize[12024:351576] +[Girl load] \n2015-10-27 15:44:55.764 initialize[12024:351576] main\n2015-10-27 15:44:55.825 initialize[12024:351576] +[Person initialize] Person\n2015-10-27 15:44:55.825 initialize[12024:351576] -[Person init]\n2015-10-27 15:44:55.825 initialize[12024:351576] -[Person init]\n2015-10-27 15:44:55.826 initialize[12024:351576] +[Person initialize] Son\n2015-10-27 15:44:55.826 initialize[12024:351576] -[Person init]\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br")])]),s("p",[s("strong",[n._v("我们会发现 Person 类的 "),s("em",[n._v("+ initialize")]),n._v(" 方法又被调用了，但是查看一下是子类 Son 调用的，也就是创建子类的时候，子类会去调用父类的 "),s("em",[n._v("+ initialize")]),n._v(" 方法。")])]),n._v(" "),s("h3",{attrs:{id:"四、总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、总结"}},[n._v("#")]),n._v(" 四、总结")]),n._v(" "),s("ul",[s("li",[n._v("如果你实现了 "),s("em",[s("strong",[n._v("+ load")])]),n._v(" 方法，那么当类被加载时它会自动被调用。这个调用非常早。"),s("br"),n._v("\n如果你实现了一个应用或框架的 "),s("em",[s("strong",[n._v("+ load")])]),n._v("，并且你的应用链接到这个框架上了，那么 "),s("em",[s("strong",[n._v("＋ load")])]),n._v(" 会在 main() 函数之前被调用。"),s("br"),n._v("\n如果你在一个可加载的 bundle 中实现了 "),s("em",[s("strong",[n._v("+ load")])]),n._v("，那么它会在 bundle 加载的过程中被调用。比如方法交换等")]),n._v(" "),s("li",[s("em",[s("strong",[n._v("+ initialize")])]),n._v(" 方法的调用看起来会更合理，通常在它里面写代码比在 "),s("em",[s("strong",[n._v("+ load")])]),n._v(" 里写更好。"),s("br"),n._v(" "),s("em",[s("strong",[n._v("+ initialize")])]),n._v(" 很有趣，因为它是懒调用的，也有可能完全不被调用。类第一次被加载时，")])]),n._v(" "),s("h3",{attrs:{id:"一、-load-调用时机和顺序原理解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、-load-调用时机和顺序原理解析"}},[n._v("#")]),n._v(" 一、+load 调用时机和顺序原理解析")]),n._v(" "),s("p",[n._v("load 方法在什么时候调用？"),s("br"),n._v("\n官方解释是：运行时，添加类或者分类的时候调用。实现此方法以在加载时执行特定于类的行为。")]),n._v(" "),s("p",[s("code",[n._v("+load")]),n._v("方法是一定会在runtime中被调用的，只要类被添加到runtime中了，就会调用"),s("code",[n._v("+load")]),n._v("方法，即"),s("strong",[n._v("只要是在"),s("code",[n._v("Compile Sources")]),n._v("中出现的文件总是会被装载，与这个类是否被用到无关，因此"),s("code",[n._v("+load")]),n._v("方法总是在main函数之前调用")]),n._v("。所以我们可以自己实现"),s("code",[n._v("+laod")]),n._v("方法来在这个时候执行一些行为。")]),n._v(" "),s("p",[s("strong",[n._v("换句话说，load是在app启动的时候加载并在")]),n._v("main函数之前调用****，从源码中找")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("_objc_init —>\n_dyld_objc_notify_register(&map_images, load_images, unmap_image);\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br")])]),s("p",[n._v("这里面的2个方法 map_images 和 load_images, map_images的作用就是加载所有的类/协议/分类，加载完成之后，就开始调用load_images，在这个方法里面看：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("load_images(const char *path __unused, const struct mach_header *mh)\n{\n    ......\n    {\n        mutex_locker_t lock2(runtimeLock);\n        prepare_load_methods((const headerType *)mh);    // 把所有需要load的类 加载一个list里面\n    }\n    call_load_methods();    // 调用load方法\n}\n\n\nvoid call_load_methods(void)\n{\n   ......\n    do {\n        while (loadable_classes_used > 0) {\n            call_class_loads();                     // 先加载类的load \n        }\n        more_categories = call_category_loads();    // 在加载category的load\n\n    } while (loadable_classes_used > 0  ||  more_categories);   \n   ......\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br")])]),s("p",[n._v("另外有意思的一点是：")]),n._v(" "),s("p",[s("strong",[s("code",[n._v("+load")]),n._v("方法不会覆盖")]),n._v("（因为**由于+load方法是根据方法地址直接调用，**"),s("strong",[n._v("并不是经过objc_msgSend函数调用")]),n._v("）。"),s("br"),n._v("\n也就是说，如果子类实现了"),s("code",[n._v("+load")]),n._v("方法，那么会先调用父类的"),s("code",[n._v("+load")]),n._v("方法，然后又去执行子类的"),s("code",[n._v("+load")]),n._v("方法。"),s("br"),n._v("\n但要注意的时+load方法只会调用一次。而且执行顺序是：类 ->父类-> 子类 ->分类。而不同类之间的顺序不一定。")]),n._v(" "),s("blockquote",[s("p",[n._v("但是这里依然有一个疑问，官方解释没有说清楚，1、分类的加载顺序是怎样的？"),s("br"),n._v("\n其实在源码中有可以看到：")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("void prepare_load_methods(const headerType *mhdr)\n{\n......\n    classref_t *classlist = \n        _getObjc2NonlazyClassList(mhdr, &count);    // 1、按照编译顺序加载所有的类(不包括分类)\n    for (i = 0; i < count; i++) {\n        schedule_class_load(remapClass(classlist[i]));  // 2、在这里  按照先父类 在子类的方式加入列表\n    }\n\n    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &count);  // 分类也是类似的方式\n    for (i = 0; i < count; i++) {\n       ......\n        add_category_to_loadable_list(cat);\n    }\n}\n\n\nstatic void schedule_class_load(Class cls)\n{\n  .......\n    schedule_class_load(cls->superclass);    //递归加载，先加载父类\n\n    add_class_to_loadable_list(cls);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br")])]),s("p",[s("em",[n._v("由以上代码中 1、2备注，得出 ：")])]),n._v(" "),s("p",[s("em",[n._v("1、先加载类的load：类的加载是按照编译顺序，同时遵循先父类再子类的方式"),s("br"),n._v("\n2、再加载分类的load：分类直接按照编译顺序，和其绑定类的继承没有关系")])]),n._v(" "),s("h3",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),s("p",[n._v("1、先加载类的load"),s("br"),n._v("\n2、再加载分类的load"),s("br"),n._v("\n3、不同的类之间加载load顺序为：有继承关系的，先加载父类load、再加载子类的load，无继承关系的，按照编译顺序"),s("br"),n._v("\n----比如顺序二 Student、OtherClass、Person，先加载Student的load，由于Person是Student的父类，所以Person的顺序比OtherClass早"),s("br"),n._v("\n4、分类的加载顺序是完全按照编译顺序，也就是谁在前面，谁先加载。和其绑定类的继承关系无关"),s("br"),n._v("\n----比如顺序二中，Student继承Person，但是其分类的顺序是 Student+JE2、Student+JE1、Person+JE，顺序是什么样，加载load就是什么样。"),s("br"),n._v("\n5、即使有类的源文件，但是编译列表中没有，那么这个类就不会被编译，也就不会执行其load方法")]),n._v(" "),s("h3",{attrs:{id:"_2、-initialize"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、-initialize"}},[n._v("#")]),n._v(" 2、+initialize")]),n._v(" "),s("p",[n._v("initialize方法在什么时候调用？"),s("br"),n._v("\n官方解释是：在类收到第一条消息之前初始化它。"),s("br"),n._v("\n换句话说，就是第一次用到它之前调用，比如初始化一个对象（其父类也会调用initialize）、调用类方法等。 从源码中找：")]),n._v(" "),s("ul",[s("li",[n._v("说明：没有发送消息的类不会调用initialize")]),n._v(" "),s("li",[n._v("如果主类有相应的分类（或多个分类），会调用分类中的initialize方法，具体调用的是哪个分类的方法，由编译顺序决定。")]),n._v(" "),s("li",[n._v("当子类没有重写initialize方法，这个时候回去执行父类的initialize方法")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("class_initialize -> initializeNonMetaClass()\nvoid initializeNonMetaClass(Class cls)\n{\n    .......\n    // Make sure super is done initializing BEFORE beginning to initialize cls.\n    // See note about deadlock above.\n    supercls = cls->superclass;\n    if (supercls  &&  !supercls->isInitialized()) {\n        initializeNonMetaClass(supercls);        // 递归加载父类的initialize\n    }\n    ........\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br")])]),s("p",[s("code",[n._v("+initialize")]),n._v("方法是在"),s("strong",[n._v("类或它的子类收到第一条消息之前被调用的")]),n._v("，这里所指的消息包括实例方法和类方法的调用，并且只会调用一次。"),s("br"),n._v(" "),s("code",[n._v("+initialize")]),n._v("方法实际上是一种惰性调用，也就是说如果一个类一直没被用到，那它的"),s("code",[n._v("+initialize")]),n._v("方法也不会被调用，这一点有利于节约资源。")]),n._v(" "),s("p",[n._v("与"),s("code",[n._v("+load")]),n._v("方法不同，却更符合我们预期的就是，"),s("code",[n._v("+initialize")]),n._v("方法会覆盖是因为调用的objc_msgSend。"),s("br"),n._v("\n也就是说如果子类实现了"),s("code",[n._v("+initialize")]),n._v("方法，就不会执行父类的了，直接执行子类本身的。"),s("br"),n._v("\n如果分类实现了"),s("code",[n._v("+initialize")]),n._v("方法，也不会再执行主类的。"),s("br"),n._v("\n所以"),s("code",[n._v("+initialize")]),n._v("方法的执行覆盖顺序是：分类 -> 子类 ->类。且只会有一个"),s("code",[n._v("+initialize")]),n._v("方法被执行。")]),n._v(" "),s("h3",{attrs:{id:"总结-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[n._v("#")]),n._v(" 总结")]),n._v(" "),s("p",[n._v("1、initialize的执行顺序为：分类 -> 子类 ->类\n2、分类的initialize方法会覆盖主类的方法（假覆盖，方法都在，只是没有执行）"),s("br"),n._v("\n3、只有在这个类有发送消息的时候才会执行initialize，比如初始化对象、调用类方法等。"),s("br"),n._v("\n4、多个分类的情况，只执行一次，具体执行哪个分类的initialize，有编译顺序决定（Build Phases -> Compile Sources 中的顺序）"),s("br"),n._v("\n5、如果子类没有重写initialize，那么会调用其父类的initialize方法")])])}),[],!1,null,null,null);s.default=e.exports}}]);