(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{399:function(s,n,a){"use strict";a.r(n);var e=a(4),t=Object(e.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h3",{attrs:{id:"dispatch-once分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-once分析"}},[s._v("#")]),s._v(" dispatch_once分析")]),s._v(" "),n("p",[s._v("在iOS开发中，我们经常使用dispatch_once去定义一个单例，来保证对象的唯一性，不过我们是否去了解过dispatch_once是如何在"),n("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[s._v("多线程"),n("OutboundLink")],1),s._v("情况下保证生成对象的唯一性呢？例如，我们经常用下面的代码块生成一个单例。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("+ (instancetype)sharedInstance {\n    static XXObject *_instance;\n    static dispatch_once_t _predicate;\n    dispatch_once(&_predicate, ^{\n        _instance = [[XXObject alloc] init];\n    });\n    return _instance;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("这段代码中涉及到两个关键词，一个是"),n("code",[s._v("dispatch_once_t变量")]),s._v("，一个是"),n("code",[s._v("dispatch_once函数")]),s._v("，下面我们逐个分析")]),s._v(" "),n("h4",{attrs:{id:"dispatch-once-t变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-once-t变量"}},[s._v("#")]),s._v(" dispatch_once_t变量")]),s._v(" "),n("p",[s._v("在once.h中找到其定义如下： typedef  long  dispatch_once_t;")]),s._v(" "),n("p",[s._v("dispatch_once_t原来是一个长整型！真是让人措手不及…")]),s._v(" "),n("h4",{attrs:{id:"dispatch-once函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-once函数"}},[s._v("#")]),s._v(" dispatch_once函数")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void dispatch_once(dispatch_once_t *val, void (^block)(void)){\n    struct Block_basic *bb = (void *)block;\n    dispatch_once_f(val, block, (void *)bb->Block_invoke);\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[s._v("可以看到，在dispatch_once中，生成一个Block_basic指针，指向了block，并把其Block_invoke函数指针传递给了dispatch_once_f\n相信大家一定有疑问，Block_basic和Block_invoke是什么东西？很遗憾，源码中找不到，我们可以推测一下：")]),s._v(" "),n("p",[s._v("Block_basic首先是一个结构体，它定义的指针可以指向void (^block)(void)类型的block\nBlock_invoke的字面意思是触发一个block，可以参考以下代码理解")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void _dispatch_call_block_and_release(void *block)\n{\n    void (^b)(void) = block;\n    b();\n    Block_release(b);\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("接下来分析核心函数"),n("code",[s._v("dispatch_once_f")]),s._v("：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void dispatch_once_f(dispatch_once_t *val, void *ctxt, void (*func)(void *)){\n    \n    volatile long *vval = val;\n    if (dispatch_atomic_cmpxchg(val, 0l, 1l)) {\n        func(ctxt); // block真正执行\n        dispatch_atomic_barrier();\n        *val = ~0l;\n    } \n    else \n    {\n        do\n        {\n            _dispatch_hardware_pause();\n        } while (*vval != ~0l);\n        dispatch_atomic_barrier();\n    }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])]),n("p",[s._v("1、dispatch_atomic_cmpxchg，它是一个宏定义，原型为__sync_bool_compare_and_swap((p), (o), (n)) ，这是LockFree给予CAS的一种原子操作机制，原理就是 如果p==o，那么将p设置为n，然后返回true;否则，不做任何处理返回false")]),s._v(" "),n("p",[s._v("2、在多线程环境中，如果某一个线程A首次进入dispatch_once_f，"),n("em",[s._v("val==0，这个时候直接将其原子操作设为1，然后执行传入dispatch_once_f的block，然后调用dispatch_atomic_barrier，最后将")]),s._v("val的值修改为~0。")]),s._v(" "),n("p",[s._v("3、dispatch_atomic_barrier是一种内存屏障，所谓内存屏障，从处理器角度来说，是用来串行化读写操作的，从软件角度来讲，就是用来解决顺序一致性问题的。编译器不是要打乱代码执行顺序吗，处理器不是要乱序执行吗，你插入一个内存屏障，就相当于告诉编译器，屏障前后的指令顺序不能颠倒，告诉处理器，只有等屏障前的指令执行完了，屏障后的指令才能开始执行。所以这里dispatch_atomic_barrier能保证只有在block执行完毕后才能修改*val的值。")]),s._v(" "),n("p",[s._v("4、在首个线程A执行block的过程中，如果其它的线程也进入dispatch_once_f，那么这个时候if的原子判断一定是返回false，于是走到了else分支，于是执行了do~while循环，其中调用了_dispatch_hardware_pause，这有助于提高性能和节省CPU耗电，pause就像nop，干的事情就是延迟空等的事情。直到首个线程已经将block执行完毕且将*val修改为~0，调用dispatch_atomic_barrier后退出。这么看来其它的线程是无法执行block的，这就保证了在dispatch_once_f的block的执行的唯一性，生成的单例也是唯一的。")]),s._v(" "),n("p",[s._v("dispatch_once死锁"),n("br"),s._v("\n参考案例 ： 单例滥用 - dispatch_once死锁造成crash（dispatch_once源码分析） - 简书")]),s._v(" "),n("p",[s._v("上面说了这么多，是不是说使用dispatch_once写单例就可以高枕无忧了呢？\n实际上并非如此，不正当地使用dispatch_once可能会造成死锁:")]),s._v(" "),n("p",[s._v("死锁方式1：\n1、某线程T1()调用单例A，且为应用生命周期内首次调用，需要使用dispatch_once(&token, block())初始化单例。\n2、上述block()中的某个函数调用了dispatch_sync_safe，同步在T2线程执行代码\n3、T2线程正在执行的某个函数需要调用到单例A，将会再次调用dispatch_once。\n4、这样T1线程在等block执行完毕，它在等待T2线程执行完毕，而T2线程在等待T1线程的dispatch_once执行完毕，造成了相互等待，故而死锁")]),s._v(" "),n("p",[s._v("死锁方式2：\n1、某线程T1()调用单例A，且为应用生命周期内首次调用，需要使用dispatch_once(&token, block())初始化单例；\n2、block中可能掉用到了B流程，B流程又调用了C流程，C流程可能调用到了单例A，将会再次调用dispatch_once；\n3、这样又造成了相互等待。")]),s._v(" "),n("p",[s._v("所以在使用写单例时要注意：")]),s._v(" "),n("p",[s._v("1、初始化要尽量简单，不要太复杂；\n2、尽量能保持自给自足，减少对别的模块或者类的依赖；\n3、单例尽量考虑使用场景，不要随意实现单例，否则这些单例一旦初始化就会一直占着资源不能释放，造成大量的资源浪费。\ndispatch_once也可以通过锁来实现，使用dispatch_semaphore,NSLock，@synchronized 这些都可以实现，但是效率没有dispatch_once高。实测也是可以的。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v(' \n// 方式1，使用synchronized最简单\n+ (instancetype)synchronizedManager {\n \n    static Person * m = nil;\n    if (m == nil) {\n        @synchronized (self) {\n            if (m == nil) {\n                // 模拟耗时操作,给其他线程进入提供机会\n                sleep(3);\n                m = [[self alloc] init];\n                NSLog(@"synchronizedManager 只执行一次是对的");\n            }\n        }\n    }\n    return m;\n}\n// 方式2，使用dispatch_semaphore,需要多一些操作,NSLock同理\nstatic dispatch_semaphore_t sem = nil;\n+ (void)initialize {\n    if (sem == nil) {\n        sem = dispatch_semaphore_create(1);\n    }\n}\n+ (instancetype)semaphoreManager {\n \n    static Person * m = nil;\n    if (m == nil) {\n        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);\n        if (m == nil) {\n            // 模拟耗时操作,给其他线程进入提供机会\n            sleep(3);\n            m = [[self alloc] init];\n            NSLog(@"semaphoreManager 只执行一次是对的");\n        }\n        dispatch_semaphore_signal(sem);\n    }\n    return m;\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br")])]),n("p",[n("strong",[s._v("解释一下为什么要判断2次 m == nil ?")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/600a3b40afa354e3f1bb5415b8922ca7.png",alt:""}})]),s._v(" "),n("p",[s._v("因为加锁/解锁是一个耗时的操作, 获取单例可能是频繁的操作, 每次都加锁/解锁 浪费性能, 所以有 了第一个判断m == nil;")]),s._v(" "),n("p",[s._v("为什么在锁内部还需要一次判断呢?")]),s._v(" "),n("p",[s._v("因为外界通过多线程调用单例方法,  第一次的时候可能有多个线程都通过了外层判断, 然后线程A 加锁成功, 创建好单例对象之后释放锁, 线程B在外界正好拿到锁, 又创建一次单例对象, 此时线程A和线程B创建的单例对象就不是一个了,在锁内部在判断一次 m == nil, 可能防止这种情况.")])])}),[],!1,null,null,null);n.default=t.exports}}]);